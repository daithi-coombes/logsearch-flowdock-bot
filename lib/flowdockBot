#!/usr/bin/env node

var YAML = require('yamljs'),
	events = require('events'),
	https = require('https'),
	logger = require('npmlog'),
	util = require('util'),
	flowdock;

var FlowDockBot = function flowdockBot(){

	events.EventEmitter.call(this);

	this.config = false;
	this.countUserRequests=0;
	this.flows = {};
	this.logData = [];
	this.target;

	var self = this;

	this.getConfig = function(){
		return this.config;
	}

	/**
	 * Makes request for flows.
	 * @see  self::parseFlows
	 * @param  {Function} fn Callback
	 * @return {object}      This instance for chaining
	 */
	this.getFlows = function(fn){

		var _cb;
		fn ? _cb=fn : _cb=this.parseFlows;
		https.get(this.target+'/flows', _cb);
		return this;
	}

	this.getFlowUsers = function(flowName, fn){

		var _cb;
		var _endpoint = this.target+'/flows/'+this.config.FLOW_ORG+'/'+flowName+'/users'; 
		fn ? _cb=fn : _cb=this.parseUsers;

		https.get(_endpoint, _cb);
		self.countUserRequests++;
		return this;
	}

	this.getUsers = function(fn){
		
		for( var i in this.flows)
			this.getFlowUsers(this.flows[i].parameterized_name, fn);

		return this;
	}

	/**
	 * Callback for this.getFlows
	 * @event flowsComplete
	 * @param  {http.serverResponse}   resp The server response
	 * @param  {callback} fn   Callback
	 */
	this.parseFlows = function(resp, cb){

		var _data = '';
		var _self = self;
		var _cb = cb;

		resp.setEncoding('utf8');
		resp.on( 'data', function(chunk){

			_data += chunk;
		});
		resp.on( 'end', function(){

			var j = JSON.parse(_data);
			for(var i in j)
				_self.flows[j[i].parameterized_name] = j[i];

			_self.emit('flowsComplete');

			if(_cb)
				_cb(j);
		});
	}

	this.parseUsers = function(resp, cb){

		var _data = '';
		var _self = self;
		var _cb = cb;

		var flowName = resp.req.path.split('/')[3];

		resp.setEncoding('utf8');
		resp.on('data', function(chunk){
			_data += chunk;
		});
		resp.on('end', function(){

			var j = JSON.parse(_data);
			_self.flows[flowName].users = j;
			_self.countUserRequests--;

			if(_cb)
				_cb(j);

			if(!_self.countUserRequests)
				_self.emit('usersComplete');
		})
	}

	this.setConfig = function(obj){

		this.config = obj;
		this.target = 'https://' + this.config.FLOW_TOKEN + '@api.flowdock.com';
	}

	this.getLogData = function(fn){

		if(!Object.keys(self.flows).length)
			throw new Error('No data recieved for writeLog(): FlowDockBot.flows is empty');

		var res = [];

		//loop through flows
		for(var i in self.flows)

			//loop through users
			for(var x in self.flows[i].users)
				res.push({
					id: self.flows[i].users[x].id,
					flow: self.flows[i].parameterized_name,
					organization: self.config.FLOW_ORG,
					nick: self.flows[i].users[x].nick,
					last_activity: new Date(self.flows[i].users[x].last_activity).toISOString()
				})

		self.logData = res;

		//do callback
		if(fn)
			fn(res);

		return this;
	}

	this.writeData = function(){

	}
}
util.inherits(FlowDockBot, events.EventEmitter);
flowdock = new FlowDockBot();

var _ = {

	getBot: function(){
		return flowdock;
	},

	/**
	 * Sets the flowdock config.
	 * @param {object} configYml Location of yaml config file
	 * @return {object} return's this for chaining
	 */
	setConfig: function(obj){
		flowdock.setConfig(obj);
		return this;
	},

	/**
	 * main() method call
	 * @return {object} return's this for chaining
	 */
	run: function(){

		if(!flowdock.config)
			throw new Error('Please set the configuration for flowdock');

		flowdock.getFlows()
			.on('flowsComplete', flowdock.getUsers)
			.on('usersComplete', flowdock.getLogData)
			.writeData();

			/**
			 * Each flowdock.getFlows() request will set a flag to act as
			 * a blocker. So if the FlowDockBot instance is still waiting
			 * the on('event') triggers can't get mixed up. The `end` event
			 * will unblock the FlowDockBot instance.
			 */
	}
};

module.exports = _;
