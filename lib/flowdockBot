#!/usr/bin/env node

var YAML = require('yamljs'),
	events = require('events'),
	exec = require('child_process').exec,
	fs = require('fs'),
	https = require('https'),
	logger = require('npmlog'),
	util = require('util'),
	flowdock

var FlowDockBot = function flowdockBot(){

	events.EventEmitter.call(this)

	this.backupLogFile = true
	this.config = false
	this.countUserRequests=0
	this.filename = process.cwd()+'/logs/flowdock.log'
	this.flows = {}
	this.logData = []
	this.maxLogSize = 1000
	this.target

	var self = this

	this.getConfig = function(){
		return this.config
	}

	/**
	 * Makes request for flows.
	 * @see  self::parseFlows
	 * @param  {Function} fn Callback
	 * @return {object}      This instance for chaining
	 */
	this.getFlows = function(fn){

		var _cb
		fn ? _cb=fn : _cb=this.parseFlows
		https.get(this.target+'/flows', _cb)
		return this
	}

	this.getFlowUsers = function(flowName, fn){

		var _cb
		var _endpoint = this.target+'/flows/'+this.config.FLOW_ORG+'/'+flowName+'/users' 
		fn ? _cb=fn : _cb=this.parseUsers

		https.get(_endpoint, _cb)
		self.countUserRequests++
		return this
	}

	this.getLogData = function(fn){

		if(!Object.keys(self.flows).length)
			throw new Error('No data recieved for writeLog(): FlowDockBot.flows is empty')

		var res = []

		//loop through flows
		for(var i in self.flows)

			//loop through users
			for(var x in self.flows[i].users)
				res.push({
					id: self.flows[i].users[x].id,
					flow: self.flows[i].parameterized_name,
					organization: self.config.FLOW_ORG,
					nick: self.flows[i].users[x].nick,
					last_activity: new Date(self.flows[i].users[x].last_activity).toISOString()
				})

		self.logData = res
		self.emit('logData')

		//do callback
		if(fn)
			fn(res)

		return this
	}

	this.getUsers = function(fn){
		
		for( var i in this.flows)
			this.getFlowUsers(this.flows[i].parameterized_name, fn)

		return this
	}

	/**
	 * Backup logfile
	 * @param  {Function} fn Callback. Takes a boolean param
	 */
	this.logBackup = function(fn){

		var _self = self

		//get logfile line count
		var cmd = 'wc "'+self.filename+'" | awk {\'print $1\'}'
		exec(cmd, function FlowDockBot_logBackupExec(error, results) {

			if(error)
				throw new Error(error)

			res = parseInt(results.trim())
			_fn = fn

			//compare result with maxLogSize
			if( res > _self.maxLogSize ){

				//create backup
				var cmd = 'mv "'+_self.filename+'" "'+_self.filename+'.bak"'
				exec(cmd, function(err){

					if(err)
						throw new Error(err)

					_fn(true)
				})
				if(!fn)
					console.log('Backed up '+_self.filename+' to '+_self.filename+'.bak')
			}

			//default run callback
			else if(fn)
				fn(res)
		})		
	}

	/**
	 * Callback for this.getFlows
	 * @event flowsComplete
	 * @param  {http.serverResponse}   resp The server response
	 * @param  {callback} fn   Callback
	 */
	this.parseFlows = function(resp, cb){

		var _data = ''
		var _self = self
		var _cb = cb

		resp.setEncoding('utf8')
		resp.on( 'data', function(chunk){

			_data += chunk
		})
		resp.on( 'end', function(){

			var j = JSON.parse(_data)
			for(var i in j)
				_self.flows[j[i].parameterized_name] = j[i]

			_self.emit('flowsComplete')

			if(_cb)
				_cb(j)
		})
	}

	this.parseUsers = function(resp, cb){

		var _data = ''
		var _self = self
		var _cb = cb

		var flowName = resp.req.path.split('/')[3]

		resp.setEncoding('utf8')
		resp.on('data', function(chunk){
			_data += chunk
		})
		resp.on('end', function(){

			var j = JSON.parse(_data)
			_self.flows[flowName].users = j
			_self.countUserRequests--

			if(_cb)
				_cb(j)

			if(!_self.countUserRequests)
				_self.emit('usersComplete')
		})
	}

	this.setConfig = function(obj){

		this.config = obj
		this.target = 'https://' + this.config.FLOW_TOKEN + '@api.flowdock.com'
	}

	this.writeData = function(fn){
		
		if(!Object.keys(self.logData).length)
			throw new Error('FlowDockBot.logData is empty. No logData gathered')

		//vars
		var cb,
			log = []
			_self = self

		//build up logfile data
		self.logData.forEach(function logDataTestForEach(item, index){
			log.push(JSON.stringify(item))
		})

		//construct callback
		fn ? 
			cb = fn : 
			cb = function(err){ 
				_self.emit('endLogWrite') 
				_self.emit('logFinished')
		        _self.logData = new Array()
			}

		//write log, clean up
		fs.appendFile(this.filename, log.join('\n'), cb)
        return self
	}

	this.on('endLogWrite', this.logBackup)
}
util.inherits(FlowDockBot, events.EventEmitter)
flowdock = new FlowDockBot()

var _ = {

	getBot: function(){
		return flowdock
	},

	/**
	 * Sets the flowdock config.
	 * @param {object} configYml Location of yaml config file
	 * @return {object} return's this for chaining
	 */
	setConfig: function(obj){
		flowdock.setConfig(obj)
		return this
	},

	/**
	 * main() method call
	 * @param {string} filename Required. The filename relative to project root.
	 * eg: 'logs/flowdock.log'
	 * @return {object} return's this for chaining
	 */
	run: function(filename){

		if(!flowdock.config)
			throw new Error('Please set the configuration for flowdock')

		if(filename)
			flowdock.filename = filename

		flowdock.getFlows()
			.on('flowsComplete', flowdock.getUsers)
			.on('usersComplete', flowdock.getLogData)
			.on('logData', function(){
				flowdock.writeData()
			})

		return this

			/**
			 * Each flowdock.getFlows() request will set a flag to act as
			 * a blocker. So if the FlowDockBot instance is still waiting
			 * the on('event') triggers can't get mixed up. The `end` event
			 * will unblock the FlowDockBot instance.
			 */
	}
}

module.exports = _
